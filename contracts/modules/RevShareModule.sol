//SPDX-License-Identifier: GPL-3.0

/**
 * @title RevShareModule
 * @author Maikel Ordaz
 * @dev Allow NFT holders to receive a share of the revenue generated by the platform
 * @dev Important notes:
 *      1. It will mint a new NFT to all users that deposit maximum contribution
 *      2. It will mint a new NFT per each 250USDC expends by a coupon buyer
 * @dev Upgradeable contract with UUPS pattern
 */
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import {UUPSUpgradeable, Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import {ReentrancyGuardTransientUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol";
import {ERC721EnumerableUpgradeable, ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import {TLDModuleImplementation} from "contracts/modules/moduleUtils/TLDModuleImplementation.sol";

import {ModuleState} from "contracts/types/TakasureTypes.sol";
import {ModuleConstants} from "contracts/helpers/libraries/constants/ModuleConstants.sol";
import {AddressAndStates} from "contracts/helpers/libraries/checks/AddressAndStates.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

pragma solidity 0.8.28;

contract RevShareModule is
    Initializable,
    UUPSUpgradeable,
    AccessControlUpgradeable,
    ReentrancyGuardTransientUpgradeable,
    TLDModuleImplementation,
    ERC721Upgradeable,
    ERC721EnumerableUpgradeable
{
    using SafeERC20 for IERC20;

    IERC20 private usdc; // Revenue token

    enum Operation {
        SINGLE_MINT,
        ACTIVATE_NFT
    }

    ModuleState private moduleState;

    address private takadaoOperator;
    string public baseURI; // Base URI for the NFTs

    uint256 public constant NFT_PRICE = 250e6; // 250 USDC, this is the max contribution
    // Tokens 9181 to 18_000 are reserved for coupon buyers
    uint256 public constant MAX_SUPPLY = 18_000;
    // Not minted, but we'll assume it is minted for the revenue calculation
    // Tokens 1 to 9180 are reserved for Takadao
    uint256 private constant TAKADAO_BALANCE = 9_180;
    uint256 private constant DECIMAL_CORRECTION = 1e6;

    uint256 private revenueRate;
    uint256 public lastUpdatedTimestamp; // Last time the rewards were updated
    uint256 public revenuePerNFTOwned;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    mapping(address => uint256) public userRevenuePerNFTPaid;
    mapping(address => uint256) public revenues;

    // Tracks if a member has claimed the NFTs, it does not track coupon buyers
    mapping(address member => bool) public claimedNFTs;
    mapping(uint256 tokenId => bool active) private isNFTActive;
    // Track coupon related values
    mapping(address couponBuyer => uint256 couponAmount) public couponAmountsByBuyer; // How much a coupon buyer has spent
    mapping(address couponBuyer => uint256 couponRedeemedAmount)
        public couponRedeemedAmountsByBuyer; // How much a coupon buyer has redeemed. It will be reset when the coupon mints new NFTs
    /*//////////////////////////////////////////////////////////////
                            EVENTS & ERRORS
    //////////////////////////////////////////////////////////////*/

    event OnCouponAmountByBuyerIncreased(address indexed buyer, uint256 amount);
    event OnCouponAmountRedeemedByBuyerIncreased(address indexed buyer, uint256 amount);
    event OnRevShareNFTMinted(address indexed owner, uint256 tokenId);
    event OnBatchRevShareNFTMinted(
        address indexed couponBuyer,
        uint256 initialTokenId,
        uint256 lastTokenId
    );
    event OnRevShareNFTActivated(address indexed couponBuyer, uint256 tokenId);
    event OnRevenueClaimed(address indexed member, uint256 amount);
    event OnBaseURISet(string indexed oldBaseUri, string indexed newBaseURI);

    error RevShareModule__MaxSupplyReached();
    error RevShareModule__NotAllowedToMint();
    error RevShareModule__NoRevenueToClaim();
    error RevShareModule__NotNFTOwner();
    error RevShareModule__NotZeroAmount();
    error RevShareModule__MintNFTFirst();
    error RevShareModule__NotAllowed();
    error RevShareModule__NotActiveToken();

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address _operator,
        address _minter,
        address _moduleManager,
        address _usdc
    ) external initializer {
        AddressAndStates._notZeroAddress(_operator);
        AddressAndStates._notZeroAddress(_moduleManager);
        AddressAndStates._notZeroAddress(_usdc);

        __UUPSUpgradeable_init();
        __AccessControl_init();
        __ReentrancyGuardTransient_init();
        __ERC721_init("RevShareNFT", "RSNFT");
        __ERC721Enumerable_init();

        _grantRole(DEFAULT_ADMIN_ROLE, _operator);
        _grantRole(ModuleConstants.TAKADAO_OPERATOR, _operator);
        _grantRole(ModuleConstants.MODULE_MANAGER, _moduleManager);
        _grantRole(ModuleConstants.COUPON_REDEEMER, _minter);
        _grantRole(MINTER_ROLE, _minter);

        usdc = IERC20(_usdc);
        takadaoOperator = _operator;

        revenueRate = 1;
        lastUpdatedTimestamp = block.timestamp;
    }

    /*//////////////////////////////////////////////////////////////
                                SETTINGS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the module state
     *  @dev Only callable from the Module Manager
     */
    function setContractState(
        ModuleState newState
    ) external override onlyRole(ModuleConstants.MODULE_MANAGER) {
        moduleState = newState;
    }

    function increaseCouponAmountByBuyer(
        address buyer,
        uint256 amount
    ) external onlyRole(ModuleConstants.COUPON_REDEEMER) {
        AddressAndStates._notZeroAddress(buyer);
        require(amount > 0, RevShareModule__NotZeroAmount());

        couponAmountsByBuyer[buyer] += amount;

        emit OnCouponAmountByBuyerIncreased(buyer, amount);
    }

    function setBaseURI(
        string calldata _newBaseURI
    ) external onlyRole(ModuleConstants.TAKADAO_OPERATOR) {
        string memory oldBaseURI = baseURI;
        baseURI = _newBaseURI;
        emit OnBaseURISet(oldBaseURI, _newBaseURI);
    }

    /*//////////////////////////////////////////////////////////////
                                  MINT
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Mint single token to a user or activate an existing token from a coupon buyer
     * @param operation The operation to perform, either SINGLE_MINT or ACTIVATE_NFT
     * @param member The address of the member to mint a single NFT. This is only used for SINGLE_MINT
     * @param couponBuyer The address of the coupon buyer to activate the NFT, only if possible. This is only used for ACTIVATE_NFT
     * @param amount The amount of USDC redeemed by the coupon buyer. This is only used for ACTIVATE_NFT
     * @dev Only callable by someone with the MINTER_ROLE
     */
    function mintOrActivate(
        Operation operation,
        address member,
        address couponBuyer,
        uint256 amount
    ) external onlyRole(MINTER_ROLE) {
        if (operation == Operation.SINGLE_MINT) {
            _mintSingle(member);
        } else if (operation == Operation.ACTIVATE_NFT) {
            _activateSingle(couponBuyer, amount);
        }
    }

    /**
     * @notice Mint multiple tokens to a coupon buyer
     * @param couponBuyer The address of the coupon buyer to mint the NFTs
     * @param couponAmount The amount of USDC bought by the coupon buyer
     * @dev Only callable by someone with the MINTER_ROLE
     */
    function batchMint(
        address couponBuyer,
        uint256 couponAmount
    ) external nonReentrant onlyRole(MINTER_ROLE) {
        AddressAndStates._notZeroAddress(couponBuyer);
        require(totalSupply() < MAX_SUPPLY, RevShareModule__MaxSupplyReached());

        uint256 totalCouponAmount = couponAmountsByBuyer[couponBuyer] + couponAmount;
        require(totalCouponAmount > 0, RevShareModule__NotZeroAmount());

        // If the new coupon amount is less than the max contribution, we only increase the coupon amount
        // in case the coupon buyer will purchase more coupons in the future
        if (totalCouponAmount < NFT_PRICE) {
            couponAmountsByBuyer[couponBuyer] = totalCouponAmount;
            emit OnCouponAmountByBuyerIncreased(couponBuyer, couponAmount);

            // We finish execution
            return;
        }

        // Check how many NFTs the coupon buyer can mint
        uint256 maxNFTsAllowed = totalCouponAmount / NFT_PRICE; // 550 / 250 = 2.2 => 2 NFTs

        // Update the coupon amount for the coupon buyer with the remaining amount, not used for minting
        couponAmountsByBuyer[couponBuyer] = totalCouponAmount - (maxNFTsAllowed * NFT_PRICE);

        uint256 firstNewTokenId = totalSupply();

        if (maxNFTsAllowed == 1) {
            _safeMint(couponBuyer, firstNewTokenId);
            emit OnRevShareNFTMinted(couponBuyer, firstNewTokenId);
        } else {
            uint256 lastNewTokenId = firstNewTokenId + maxNFTsAllowed;

            for (uint256 i = firstNewTokenId; i < lastNewTokenId; ++i) {
                _safeMint(couponBuyer, i);
            }

            emit OnBatchRevShareNFTMinted(couponBuyer, firstNewTokenId, lastNewTokenId);
        }
    }

    /**
     * @notice Transfer override function. Only active NFTs can be transferred
     * @dev The revenues are updated for both the sender and the receiver
     */
    function transfer(address to, uint256 tokenId) external {
        require(isNFTActive[tokenId], RevShareModule__NotActiveToken());

        _updateRevenue(msg.sender);
        _updateRevenue(to);

        _safeTransfer(msg.sender, to, tokenId, "");
    }

    /**
     * @notice Transfer from override function. Only active NFTs can be transferred
     * @dev The revenues are updated for both the sender and the receiver
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public override(ERC721Upgradeable, IERC721) {
        require(isNFTActive[tokenId], RevShareModule__NotActiveToken());

        _updateRevenue(from);
        _updateRevenue(to);

        super.transferFrom(from, to, tokenId);
    }

    function balanceOf(
        address owner
    ) public view override(ERC721Upgradeable, IERC721) returns (uint256) {
        if (owner == takadaoOperator) return TAKADAO_BALANCE;
        return super.balanceOf(owner);
    }

    function totalSupply() public view override returns (uint256) {
        return super.totalSupply() + TAKADAO_BALANCE;
    }

    /*//////////////////////////////////////////////////////////////
                             CLAIM REVENUE
    //////////////////////////////////////////////////////////////*/

    function claimRevenue() external {
        require(balanceOf(msg.sender) > 0, RevShareModule__NotNFTOwner());

        // Update the revenues
        _updateRevenue(msg.sender);

        uint256 revenue = revenues[msg.sender];

        require(revenue > 0, RevShareModule__NoRevenueToClaim());

        revenues[msg.sender] = 0;
        usdc.safeTransfer(msg.sender, revenue);

        emit OnRevenueClaimed(msg.sender, revenue);
    }

    /*//////////////////////////////////////////////////////////////
                                GETTERS
    //////////////////////////////////////////////////////////////*/

    function isActive(uint256 tokenId) external view returns (bool) {
        if (tokenId < TAKADAO_BALANCE) return true;
        return isNFTActive[tokenId];
    }

    function getRevenuePerNFT() external view returns (uint256) {
        return _revenuePerNFT();
    }

    /**
     * @notice How much a user have earned in total
     */
    function getRevenueEarnedByUser(address user) external view returns (uint256) {
        return _revenueEarnedByUser(user);
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        if (tokenId >= TAKADAO_BALANCE) {
            _requireOwned(tokenId);
        }

        string memory str = Strings.toString(tokenId);
        uint256 length = bytes(str).length;

        if (length >= 5) {
            return str; // already 5 digits or more
        }

        // Add (5 - length) zeros in front
        string memory zeros;
        for (uint256 i = 0; i < 5 - length; i++) {
            zeros = string.concat(zeros, "0");
        }

        string memory paddedTokenId = string.concat(zeros, str);

        return bytes(baseURI).length > 0 ? string.concat(baseURI, paddedTokenId, ".json") : "";
    }

    /*//////////////////////////////////////////////////////////////
                           INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Mint a single token to a user
     * @param _member The address of the member to mint a single NFT
     * @dev All NFTs minted to normal members are active from the start
     */
    function _mintSingle(address _member) internal nonReentrant {
        AddressAndStates._notZeroAddress(_member);
        require(totalSupply() < MAX_SUPPLY, RevShareModule__MaxSupplyReached());
        require(!claimedNFTs[_member], RevShareModule__NotAllowedToMint());

        uint256 tokenId = totalSupply();

        // Update the revenues
        _updateRevenue(_member);
        _updateRevenue(takadaoOperator);

        // All NFTs minted to normal members are active from the start
        isNFTActive[tokenId] = true;
        claimedNFTs[_member] = true;

        _safeMint(_member, tokenId);

        emit OnRevShareNFTMinted(_member, tokenId);
    }

    /**
     * @notice Activate a single token from a coupon buyer
     * @param _couponBuyer The address of the coupon buyer to activate the NFT
     * @param _amount The amount of USDC redeemed by the coupon buyer
     */
    function _activateSingle(address _couponBuyer, uint256 _amount) internal {
        AddressAndStates._notZeroAddress(_couponBuyer);
        uint256 bal = balanceOf(_couponBuyer);
        require(bal > 0, RevShareModule__MintNFTFirst());

        uint256 currentRedeemedAmount = couponRedeemedAmountsByBuyer[_couponBuyer];
        uint256 newRedeemedAmount = currentRedeemedAmount + _amount;

        // If the new redeemed amount is less than the max contribution, we only increase the redeemed amount
        if (newRedeemedAmount < NFT_PRICE) {
            couponRedeemedAmountsByBuyer[_couponBuyer] = newRedeemedAmount;
            emit OnCouponAmountRedeemedByBuyerIncreased(_couponBuyer, _amount);

            // We finish execution
            return;
        }

        couponRedeemedAmountsByBuyer[_couponBuyer] = newRedeemedAmount - NFT_PRICE;

        // Update the revenues
        _updateRevenue(_couponBuyer);
        _updateRevenue(takadaoOperator);

        // It is only possible to activate one NFT at a time, so we break the loop after finding the first inactive one
        for (uint256 i; i < bal; ++i) {
            uint256 tokenId = tokenOfOwnerByIndex(_couponBuyer, i);
            if (!isNFTActive[tokenId]) {
                isNFTActive[tokenId] = true;
                emit OnRevShareNFTActivated(_couponBuyer, tokenId);
                break;
            }
        }
    }

    function _updateRevenue(address _user) internal {
        revenuePerNFTOwned = _revenuePerNFT();
        lastUpdatedTimestamp = block.timestamp;

        revenues[_user] = _revenueEarnedByUser(_user);
        userRevenuePerNFTPaid[_user] = revenuePerNFTOwned;
    }

    function _revenuePerNFT() internal view returns (uint256) {
        return (revenuePerNFTOwned +
            ((revenueRate * (block.timestamp - lastUpdatedTimestamp) * DECIMAL_CORRECTION) /
                MAX_SUPPLY));
    }

    function _revenueEarnedByUser(address _user) internal view returns (uint256) {
        uint256 bal = balanceOf(_user);

        uint256 activeNFTs;

        if (_user == takadaoOperator) {
            activeNFTs = bal;
        } else {
            for (uint256 i; i < bal; ++i) {
                uint256 tokenId = tokenOfOwnerByIndex(_user, i);

                if (isNFTActive[tokenId]) ++activeNFTs;
            }
        }

        return (((activeNFTs * (_revenuePerNFT() - userRevenuePerNFTPaid[_user])) /
            DECIMAL_CORRECTION) + revenues[_user]);
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    /// @notice Needed override
    function _update(
        address to,
        uint256 tokenId,
        address auth
    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (address) {
        return super._update(to, tokenId, auth);
    }

    /// @notice Needed override
    function _increaseBalance(
        address account,
        uint128 amount
    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {
        super._increaseBalance(account, amount);
    }

    /// @notice Needed override
    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        virtual
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable, AccessControlUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    /// @notice Needed override
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(ModuleConstants.TAKADAO_OPERATOR) {}
}

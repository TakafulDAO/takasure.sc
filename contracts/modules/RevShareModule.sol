//SPDX-License-Identifier: GPL-3.0

/**
 * @title RevShareModule
 * @author Maikel Ordaz
 * @dev Allow NFT holders to receive a share of the revenue generated by the platform
 * @dev Important notes:
 *      1. It will mint a new NFT to all users that deposit maximum contribution
 *      2. It will mint a new NFT per each 250USDC expends by a coupon buyer
 * @dev Upgradeable contract with UUPS pattern
 */
import {IModuleManager} from "contracts/interfaces/IModuleManager.sol";
import {IPrejoinModule} from "contracts/interfaces/IPrejoinModule.sol";
import {ITakasureReserve} from "contracts/interfaces/ITakasureReserve.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {UUPSUpgradeable, Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {TLDModuleImplementation} from "contracts/modules/moduleUtils/TLDModuleImplementation.sol";

import {ModuleState} from "contracts/types/TakasureTypes.sol";
import {ModuleConstants} from "contracts/helpers/libraries/constants/ModuleConstants.sol";
import {AddressAndStates} from "contracts/helpers/libraries/checks/AddressAndStates.sol";
import {Member} from "contracts/types/TakasureTypes.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.28;

contract RevShareModule is
    Initializable,
    UUPSUpgradeable,
    AccessControlUpgradeable,
    TLDModuleImplementation,
    ERC721Upgradeable
{
    using SafeERC20 for IERC20;

    IModuleManager private moduleManager;
    IPrejoinModule private prejoinModule;
    ITakasureReserve private takasureReserve;
    IERC20 private usdc;

    ModuleState private moduleState;

    uint256 public constant MAX_CONTRIBUTION = 250e6; // 250 USDC
    uint256 public constant TOTAL_SUPPLY = 18_000;
    uint256 private constant DECIMAL_CORRECTION = 1e6;
    uint256 public latestTokenId;

    bool private prejoinActive;

    uint256 public userRevShareRate;
    uint256 public takadaoRevShareRate;

    mapping(address member => bool alreadyClaimed) public claimedNFTs;
    mapping(address couponBuyer => uint256 couponAmount) public couponAmountsByBuyer;

    /*//////////////////////////////////////////////////////////////
                            EVENTS & ERRORS
    //////////////////////////////////////////////////////////////*/

    event OnCouponBuyerAllowed(address indexed buyer, uint256 amount);
    event OnTakasureReserveSet(address indexed takasureReserve);
    event OnRevShareNFTMinted(address indexed member, uint256 tokenId);

    error RevShareModule__MaxSupplyReached();
    error RevShareModule__PrejoinStillActive();
    error RevShareModule__NotAllowedToMint();

    /// @custom:oz-upgrades-unsafe-allow-constructor
    constructor() {
        _disableInitializers();
    }

    // TODO: Initialize the URI when set, skip for now just for easier testing
    function initialize(
        address _operator,
        address _moduleManager,
        address _prejoinModule,
        address _usdc
    ) external initializer {
        AddressAndStates._notZeroAddress(_operator);
        AddressAndStates._notZeroAddress(_moduleManager);

        __UUPSUpgradeable_init();
        __AccessControl_init();
        __ERC721_init("RevShareNFT", "RSNFT");

        _grantRole(ModuleConstants.TAKADAO_OPERATOR, _operator);
        _grantRole(ModuleConstants.MODULE_MANAGER, _moduleManager);

        moduleManager = IModuleManager(_moduleManager);
        prejoinModule = IPrejoinModule(_prejoinModule);
        usdc = IERC20(_usdc);

        prejoinActive = true;
    }

    /*//////////////////////////////////////////////////////////////
                                SETTINGS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the module state
     *  @dev Only callble from the Module Manager
     */
    function setContractState(
        ModuleState newState
    ) external override onlyRole(ModuleConstants.MODULE_MANAGER) {
        moduleState = newState;
    }

    /**
     * @notice Set the Takasure Reserve contract when deployed
     */
    function setTakasureReserve(
        address _takasureReserve
    ) external onlyRole(ModuleConstants.TAKADAO_OPERATOR) {
        AddressAndStates._notZeroAddress(_takasureReserve);

        // To avoid unexpected behavior we need to ensure the prejoin is already disabled
        require(
            !moduleManager.isActiveModule(address(prejoinModule)),
            RevShareModule__PrejoinStillActive()
        );

        prejoinActive = false;
        takasureReserve = ITakasureReserve(_takasureReserve);

        emit OnTakasureReserveSet(_takasureReserve);
    }

    function allowCouponBuyer(
        address buyer,
        uint256 amount
    ) external onlyRole(ModuleConstants.TAKADAO_OPERATOR) {
        AddressAndStates._notZeroAddress(buyer);

        couponAmountsByBuyer[buyer] += amount;
        claimedNFTs[buyer] = false;

        emit OnCouponBuyerAllowed(buyer, amount);
    }

    function setUserRevShareRate() external onlyRole(ModuleConstants.TAKADAO_OPERATOR) {
        _userRevShareRate();
    }

    function setTakadaoRevShareRate() external onlyRole(ModuleConstants.TAKADAO_OPERATOR) {
        _takadaoRevShareRate();
    }

    /*//////////////////////////////////////////////////////////////
                                  MINT
    //////////////////////////////////////////////////////////////*/

    function mint() external {
        require(latestTokenId < TOTAL_SUPPLY, RevShareModule__MaxSupplyReached());

        // Check if the caller must be KYCed and paid the maximum contribution
        if (prejoinActive) {
            // If prejoin is active check in the Prejoin Module
            (uint256 contributionBeforeFee, , , ) = prejoinModule.getPrepaidMember(msg.sender);
            require(
                prejoinModule.isMemberKYCed(msg.sender) &&
                    contributionBeforeFee == MAX_CONTRIBUTION,
                RevShareModule__NotAllowedToMint()
            );
        } else {
            // Otherwise check in the Takasure Reserve
            Member memory member = takasureReserve.getMemberFromAddress(msg.sender);
            require(
                member.isKYCVerified && member.contribution == MAX_CONTRIBUTION,
                RevShareModule__NotAllowedToMint()
            );
        }

        ++latestTokenId;
        claimedNFTs[msg.sender] = true;
        _safeMint(msg.sender, latestTokenId);

        emit OnRevShareNFTMinted(msg.sender, latestTokenId);
    }

    function batchMint() external {
        require(latestTokenId < TOTAL_SUPPLY, RevShareModule__MaxSupplyReached());
        require(
            couponAmountsByBuyer[msg.sender] >= MAX_CONTRIBUTION,
            RevShareModule__NotAllowedToMint()
        );

        uint256 firstTokenId = latestTokenId + 1;
        uint256 lastTokenId = firstTokenId + (couponAmountsByBuyer[msg.sender] / MAX_CONTRIBUTION);

        latestTokenId = lastTokenId;

        for (uint256 i = firstTokenId; i <= lastTokenId; ++i) {
            claimedNFTs[msg.sender] = true;
            _safeMint(msg.sender, i);

            emit OnRevShareNFTMinted(msg.sender, i);
        }
    }

    /*//////////////////////////////////////////////////////////////
                            REVENUE REWARDS
    //////////////////////////////////////////////////////////////*/

    function claimRevenueRewards() external {}

    /*//////////////////////////////////////////////////////////////
                           INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Precompute the user and Takadao revenue share rates
     */
    function _userRevShareRate() internal {
        // userRevShareRate = (1 / TOTAL_SUPPLY) * 100;
        userRevShareRate = (100 * DECIMAL_CORRECTION) / TOTAL_SUPPLY;
    }

    /**
     * @notice Precompute the user and Takadao revenue share rates
     */
    function _takadaoRevShareRate() internal {
        // takadaoRevShareRate = (TOTAL_SUPPLY - Minted / TOTAL_SUPPLY) * 100;
        takadaoRevShareRate = ((TOTAL_SUPPLY - latestTokenId) * DECIMAL_CORRECTION) / TOTAL_SUPPLY;
    }

    /**
     * @notice Needed override
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override(ERC721Upgradeable, AccessControlUpgradeable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(ModuleConstants.TAKADAO_OPERATOR) {}
}

//SPDX-License-Identifier: GPL-3.0

/**
 * @title RevenueShareModule
 * @author Maikel Ordaz
 * @dev Allow NFT holders to receive a share of the revenue generated by the platform
 * @dev Upgradeable contract with UUPS pattern
 */
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IAddressManager} from "contracts/interfaces/IAddressManager.sol";
import {IRevShareNFT} from "contracts/interfaces/IRevShareNFT.sol";

import {UUPSUpgradeable, Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {ReentrancyGuardTransientUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol";
import {ModuleImplementation} from "contracts/modules/moduleUtils/ModuleImplementation.sol";

import {ModuleState, ProtocolAddressType} from "contracts/types/TakasureTypes.sol";
import {ModuleErrors} from "contracts/helpers/libraries/errors/ModuleErrors.sol";
import {Roles} from "contracts/helpers/libraries/constants/Roles.sol";
import {AddressAndStates} from "contracts/helpers/libraries/checks/AddressAndStates.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.28;

contract RevShareModule is
    ModuleImplementation,
    Initializable,
    UUPSUpgradeable,
    ReentrancyGuardTransientUpgradeable
{
    using SafeERC20 for IERC20;

    // New streaming state
    uint256 public rewardsDuration;
    uint256 public periodFinish; // Shared for both pools

    uint256 public approvedDeposits; // Total amount of approved deposits to be distributed as revenue
    uint256 public revenuesAvailableDate; // Timestamp to start the distribution. It does not mean the calculation starts at this date

    uint256 private constant PIONEERS_SHARE = 75; // In percentage (75%)
    uint256 private constant TAKADAO_SHARE = 25; // In percentage (25%)
    uint256 private constant WAD = 1e18; // Fixed point for per-second rates

    // Scaled rates: tokens * 1e18 / second
    uint256 public rewardRateTakadaoScaled;
    uint256 public rewardRatePioneersScaled;

    uint256 public lastUpdateTime;
    uint256 public revenuePerNftOwnedByPioneers; // Cumulative revenue per NFT for pioneers pool
    uint256 public takadaoRevenueScaled; // Cumulative revenue per NFT for Takadao pool

    mapping(address account => uint256 revenue) public revenuePerAccount;
    mapping(address pioneer => uint256 revenue) public pioneerRevenuePerNftPaid;
    uint256 public takadaoRevenuePaidScaled; // No need to track per address, only the revenue receiver can earn from this stream

    /*//////////////////////////////////////////////////////////////
                           EVENTS AND ERRORS
    //////////////////////////////////////////////////////////////*/

    event OnAvailableDateSet(uint256 timestamp);
    event OnRewardsDurationSet(uint256 duration);
    event OnDeposit(uint256 amount);
    event OnBalanceSwept(uint256 amount);
    event OnRevenueShareClaimed(address indexed account, uint256 amount);

    error RevShareModule__RevenuesNotAvailableYet();
    error RevShareModule__NotZeroValue();
    error RevShareModule__InvalidDate();
    error RevShareModule__NothingToSweep();
    error RevShareModule__ActiveStreamOngoing();
    error RevShareModule__InsufficientApprovedDeposits();

    /*//////////////////////////////////////////////////////////////
                             INITIALIZATION
    //////////////////////////////////////////////////////////////*/

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _addressManagerAddress) external initializer {
        AddressAndStates._notZeroAddress(_addressManagerAddress);
        __UUPSUpgradeable_init();
        __ReentrancyGuardTransient_init();

        addressManager = IAddressManager(_addressManagerAddress);

        revenuesAvailableDate = block.timestamp;

        rewardsDuration = 90 days; // default stream windows
    }

    /*//////////////////////////////////////////////////////////////
                                SETTERS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the date when revenues will be available to claim
     * @param timestamp The timestamp when revenues will be available to claim
     */
    function setAvailableDate(
        uint256 timestamp
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(
            ModuleState.Enabled,
            address(this),
            IAddressManager(addressManager).getProtocolAddressByName("MODULE_MANAGER").addr
        );
        require(timestamp > block.timestamp, RevShareModule__InvalidDate());
        revenuesAvailableDate = timestamp;

        emit OnAvailableDateSet(timestamp);
    }

    function setRewardsDuration(
        uint256 duration
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(
            ModuleState.Enabled,
            address(this),
            IAddressManager(addressManager).getProtocolAddressByName("MODULE_MANAGER").addr
        );
        require(duration > 0, RevShareModule__NotZeroValue());
        require(block.timestamp >= periodFinish, RevShareModule__ActiveStreamOngoing()); // Avoid mid-stream changes
        rewardsDuration = duration;
        emit OnRewardsDurationSet(duration);
    }

    /**
     * @notice Early release the revenues to be available to claim
     * @dev Only callable by an operator
     * @dev To be called in case the revenuesAvailableDate is set too far in the future
     */
    function releaseRevenues() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(
            ModuleState.Enabled,
            address(this),
            IAddressManager(addressManager).getProtocolAddressByName("MODULE_MANAGER").addr
        );
        require(block.timestamp < revenuesAvailableDate, RevShareModule__InvalidDate());
        revenuesAvailableDate = block.timestamp;
        emit OnAvailableDateSet(block.timestamp);
    }

    /*//////////////////////////////////////////////////////////////
                                DEPOSITS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Notify the contract about new revenue to be distributed
     * @param amount The amount of revenue to be distributed
     * @dev Only callable by specific contracts
     * @dev The contract must have enough allowance to transfer the tokens
     * @dev Splits deposits between Takadao (25%) and pioneers (75%)
     * @dev Sets new reward rates for both pools, with carry-over if the previous stream was not finished
     * @dev Increases the approved deposits for accounting purposes
     */
    function notifyNewRevenue(
        uint256 amount
    ) external onlyType(ProtocolAddressType.Module, address(addressManager)) nonReentrant {
        require(amount > 0, RevShareModule__NotZeroValue());

        // Update approved deposits for accounting purposes
        approvedDeposits += amount;

        // Checkpoint (old rates are settled up to now)
        _updateGlobal();

        // Split between Takadao and pioneers
        uint256 pioneersShare = (amount * PIONEERS_SHARE) / 100;
        uint256 takadaoShare = (amount * TAKADAO_SHARE) / 100;

        // Recompute reward rates with carry-over
        uint256 currentTime = block.timestamp;
        if (currentTime >= periodFinish) {
            rewardRatePioneersScaled = (pioneersShare * WAD) / rewardsDuration;
            rewardRateTakadaoScaled = (takadaoShare * WAD) / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - currentTime;
            uint256 leftoverPioneersScaled = remaining * rewardRatePioneersScaled;
            uint256 leftoverTakadaoScaled = remaining * rewardRateTakadaoScaled;

            rewardRatePioneersScaled =
                (pioneersShare * WAD + leftoverPioneersScaled) /
                rewardsDuration;
            rewardRateTakadaoScaled =
                (takadaoShare * WAD + leftoverTakadaoScaled) /
                rewardsDuration;
        }

        lastUpdateTime = currentTime;
        periodFinish = currentTime + rewardsDuration;

        // Pull the tokens from the sender
        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );

        contributionToken.safeTransferFrom(msg.sender, address(this), amount);

        emit OnDeposit(amount);
    }

    /**
     * @notice Sweep the non approved deposits to avoid accounting issues
     * @dev Only callable by an operator
     */
    function sweepNonApprovedDeposits() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(
            ModuleState.Enabled,
            address(this),
            IAddressManager(addressManager).getProtocolAddressByName("MODULE_MANAGER").addr
        );

        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 bal = contributionToken.balanceOf(address(this));
        if (bal <= approvedDeposits) revert RevShareModule__NothingToSweep();

        uint256 balanceToSweep = bal - approvedDeposits;

        contributionToken.safeTransfer(msg.sender, balanceToSweep);

        emit OnBalanceSwept(balanceToSweep);
    }

    /*//////////////////////////////////////////////////////////////
                               EMERGENCY
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Emergency withdraw tokens from the contract
     * @dev Only callable by an operator
     * @dev Withdraws all the balance of the revenue token to the operator
     */
    function emergencyWithdraw() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 balance = contributionToken.balanceOf(address(this));

        // Halt streams & reset accounting
        rewardRatePioneersScaled = 0;
        rewardRateTakadaoScaled = 0;
        periodFinish = block.timestamp;
        lastUpdateTime = block.timestamp;
        approvedDeposits = 0; // Reset approved deposits

        contributionToken.safeTransfer(msg.sender, balance);
    }

    /*//////////////////////////////////////////////////////////////
                                 CLAIMS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Claim the revenue share earned by the pioneer
     * @return revenue The amount of revenue share claimed
     */
    function claimRevenueShare() external nonReentrant returns (uint256 revenue) {
        AddressAndStates._onlyModuleState(
            ModuleState.Enabled,
            address(this),
            IAddressManager(addressManager).getProtocolAddressByName("MODULE_MANAGER").addr
        );
        require(
            block.timestamp >= revenuesAvailableDate,
            RevShareModule__RevenuesNotAvailableYet()
        );

        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        address revenueReceiver = _getRevenueReceiver();

        // Currently a pioneer or former pioneer with unpaid revenue
        bool pioneerEligible = (revShareNFT.balanceOf(msg.sender) > 0) ||
            (revenuePerAccount[msg.sender] > 0);

        address beneficiary;

        if (pioneerEligible)
            beneficiary = msg.sender; // earns from pioneers stream
        else if (_callerIsClaimer())
            beneficiary = revenueReceiver; // earns from Takadao stream
        else revert ModuleErrors.Module__NotAuthorizedCaller(); // Only pioneers or the revenue claimer can call

        // Update global and user accruals
        _updateRevenue(beneficiary);

        revenue = revenuePerAccount[beneficiary];

        if (revenue == 0) return 0;

        if (revenue > 0) {
            revenuePerAccount[beneficiary] = 0;

            IERC20 contributionToken = IERC20(
                addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
            );
            contributionToken.safeTransfer(beneficiary, revenue);

            // Sync approved deposits
            if (approvedDeposits < revenue) revert RevShareModule__InsufficientApprovedDeposits();
            approvedDeposits -= revenue;

            emit OnRevenueShareClaimed(beneficiary, revenue);
        }
    }

    /**
     * @notice Update the revenue share for a pioneer
     * @param pioneer The address of the pioneer
     */
    function updateRevenue(address pioneer) external {
        _updateRevenue(pioneer);
    }

    /*//////////////////////////////////////////////////////////////
                             VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function lastTimeApplicable() public view returns (uint256) {
        return _lastTimeApplicable();
    }

    /**
     * @notice View the revenue to be distributed for a given duration
     * @param duration The duration in seconds
     * @return The amount of revenue to be distributed
     */
    function getRevenueForDuration(uint256 duration) external view returns (uint256, uint256) {
        return (
            (duration * rewardRatePioneersScaled) / WAD,
            (duration * rewardRateTakadaoScaled) / WAD
        );
    }

    /// @notice View the revenue earned by a pioneer
    function earnedByPioneers(address account) external view returns (uint256) {
        if (account == _getRevenueReceiver()) return 0; // Takadao does not earn from this stream
        return _earnedByPioneers(account);
    }

    /// @notice View the revenue earned by Takadao
    function earnedByTakadao(address account) external view returns (uint256) {
        if (account != _getRevenueReceiver()) return 0; // Only the revenue receiver earns from this stream
        return _earnedByTakadao(account);
    }

    /// @notice View the revenue per NFT for pioneers
    function getRevenuePerNftOwnedByPioneers() external view returns (uint256) {
        return _revenuePerNftOwnedByPioneers();
    }

    /// @notice View the revenue per NFT for Takadao
    function getTakadaoRevenueScaled() external view returns (uint256) {
        return _takadaoRevenueScaled();
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function _lastTimeApplicable() internal view returns (uint256) {
        uint256 _pf = periodFinish;

        if (_pf == 0) return block.timestamp;
        return block.timestamp < _pf ? block.timestamp : _pf;
    }

    function _getRevenueReceiver() internal view returns (address) {
        return addressManager.getProtocolAddressByName("REVENUE_RECEIVER").addr;
    }

    function _callerIsClaimer() internal view returns (bool) {
        return addressManager.hasRole(Roles.REVENUE_CLAIMER, msg.sender);
    }

    /// @dev Updates the global revenue for both pools
    function _updateGlobal() internal {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        uint256 applicableTime = _lastTimeApplicable();
        uint256 elapsed = applicableTime - lastUpdateTime;

        if (elapsed == 0) return; // No time has passed since last update

        // Takadao 25%: accrued globally, not per NFT
        takadaoRevenueScaled = takadaoRevenueScaled + (elapsed * rewardRateTakadaoScaled);

        // Pioneers 75%: accrued per NFT
        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply > 0) {
            revenuePerNftOwnedByPioneers =
                revenuePerNftOwnedByPioneers +
                ((elapsed * rewardRatePioneersScaled) / currentSupply);
        }

        lastUpdateTime = applicableTime;
    }

    function _updateRevenue(address _account) internal {
        // Always update global state first
        _updateGlobal();

        // If account is address zero, we are done
        if (_account == address(0)) return;

        // Settle the account accruals on the corresponding stream
        // In pioneers stream everyone but the revenue receiver earns
        address revenueReceiver = _getRevenueReceiver();

        // Pioneers stream (75%)
        if (_account != revenueReceiver) {
            uint256 newearnedByPioneers = _earnedByPioneers(_account);
            revenuePerAccount[_account] = newearnedByPioneers;
            pioneerRevenuePerNftPaid[_account] = revenuePerNftOwnedByPioneers;
        }

        // Takadao stream (25%)
        // Only the revenue receiver earns
        if (_account == revenueReceiver) {
            uint256 newearnedByTakadao = _earnedByTakadao(_account);
            revenuePerAccount[_account] = newearnedByTakadao; // Reuse the same revenue bucket
            takadaoRevenuePaidScaled = takadaoRevenueScaled;
        }
    }

    function _revenuePerNftOwnedByPioneers() internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply == 0) return revenuePerNftOwnedByPioneers;

        uint256 elapsed = _lastTimeApplicable() - lastUpdateTime;

        // Returns scaled accumulator
        return
            revenuePerNftOwnedByPioneers + ((elapsed * rewardRatePioneersScaled) / currentSupply);
    }

    function _takadaoRevenueScaled() internal view returns (uint256) {
        uint256 elapsed = _lastTimeApplicable() - lastUpdateTime;

        // Returns a global scaled accumulator, not per NFT
        return takadaoRevenueScaled + (elapsed * rewardRateTakadaoScaled);
    }

    function _earnedByTakadao(address _account) internal view returns (uint256) {
        // Only the revenue receiver earns from this stream
        address revenueReceiver = _getRevenueReceiver();
        if (_account != revenueReceiver) return revenuePerAccount[_account];

        uint256 deltaScaled = _takadaoRevenueScaled() - takadaoRevenuePaidScaled;

        // Convert scaled back to token units
        return (deltaScaled / WAD) + revenuePerAccount[_account];
    }

    function _earnedByPioneers(address account) internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );
        address revenueReceiver = _getRevenueReceiver();

        if (account == revenueReceiver) {
            // Takadao does not participate in the 75% stream
            return revenuePerAccount[account];
        }

        uint256 balance = revShareNFT.balanceOf(account);
        uint256 deltaScaled = _revenuePerNftOwnedByPioneers() - pioneerRevenuePerNftPaid[account];

        // Convert scaled back to token units
        return (balance * deltaScaled) / WAD + revenuePerAccount[account];
    }

    ///@dev required by the OZ UUPS module
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(Roles.OPERATOR, address(addressManager)) {}
}

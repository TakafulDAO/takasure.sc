//SPDX-License-Identifier: GPL-3.0

/**
 * @title RevenueShareModule
 * @author Maikel Ordaz
 * @dev Allow NFT holders to receive a share of the revenue generated by the platform
 * @dev Upgradeable contract with UUPS pattern
 */
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IAddressManager} from "contracts/interfaces/IAddressManager.sol";
import {IRevShareNFT} from "contracts/interfaces/IRevShareNFT.sol";

import {UUPSUpgradeable, Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {ReentrancyGuardTransientUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol";
import {TLDModuleImplementation} from "contracts/modules/moduleUtils/TLDModuleImplementation.sol";

import {ModuleState, ProtocolAddressType} from "contracts/types/TakasureTypes.sol";
import {ModuleErrors} from "contracts/helpers/libraries/errors/ModuleErrors.sol";
import {Roles} from "contracts/helpers/libraries/constants/Roles.sol";
import {AddressAndStates} from "contracts/helpers/libraries/checks/AddressAndStates.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.28;

contract RevShareModule is
    TLDModuleImplementation,
    Initializable,
    UUPSUpgradeable,
    ReentrancyGuardTransientUpgradeable
{
    using SafeERC20 for IERC20;

    // New streaming state
    uint256 public rewardsDuration;
    uint256 public periodFinish; // Shared for both pools

    uint256 public approvedDeposits; // Total amount of approved deposits to be distributed as revenue
    uint256 public revenuesAvailableDate; // Timestamp to start the distribution. It does not mean the calculation starts at this date
    uint256 public lastTimestampToDistributeRevenues; // Last timestamp to distribute revenues when distributions are turned off. 0 if distributions are active

    // TODO: Ask at the end, deliver the math first. For now will be 0
    // ? Question: Still not clear if this is 75% and 25% and we differentiate different reward rate according the caller
    // ? Or if it is the same reward rate for all th callers but we apply the formula just for the 75% or 25% of the balance depending on the caller
    uint256 private constant PIONEERS_SHARE = 75; // In percentage (75%)
    uint256 private constant TAKADAO_SHARE = 25; // In percentage (25%)
    uint256 public rewardRateTakadao; // Reward rate per second to distribute among Takadao (25%)
    uint256 public rewardRatePioneers; // Reward rate per second to distribute among pioneers (75%)

    uint256 public rewardRate; // Reward rate per second to distribute among NFT holders
    uint256 public lastUpdateTime;
    uint256 public revenuePerNftOwned; // Accumulates the total revenue a single NFT has earned if it was owned since the beginning
    uint256 public revenuePerNftPioneers; // Cumulative revenue per NFT for pioneers pool
    uint256 public revenuePerNftTakadao; // Cumulative revenue per NFT for Takadao pool

    uint256 private constant PRECISION_FACTOR = 1e6;

    mapping(address pioneer => uint256 revenue) public revenuePerPioneer;
    mapping(address pioneer => uint256 revenue) public pioneerRevenuePerNftPaid;

    /*//////////////////////////////////////////////////////////////
                           EVENTS AND ERRORS
    //////////////////////////////////////////////////////////////*/

    event OnAvailableDateSet(uint256 timestamp);
    event OnRewardsDurationSet(uint256 duration);
    event OnDistributionsActiveSet(bool active, uint256 periodFinish);
    event OnTakadaoAddressAdded(address indexed addr);
    event OnTakadaoAddressRemoved(address indexed addr);
    event OnDeposit(uint256 amount);
    event OnBalanceSwept(uint256 amount);
    event OnRevenueShareClaimed(address indexed pioneer, uint256 amount);

    error RevShareModule__RevenuesNotAvailableYet();
    error RevShareModule__NotZeroValue();
    error RevShareModule__InvalidDate();
    error RevShareModule__NotTakadaoAddress();
    error RevShareModule__NothingToSweep();

    /*//////////////////////////////////////////////////////////////
                             INITIALIZATION
    //////////////////////////////////////////////////////////////*/

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _addressManagerAddress) external initializer {
        AddressAndStates._notZeroAddress(_addressManagerAddress);
        __UUPSUpgradeable_init();
        __ReentrancyGuardTransient_init();

        addressManager = IAddressManager(_addressManagerAddress);

        revenuesAvailableDate = block.timestamp; // TODO: Change if needed

        rewardsDuration = 7 days; // default stream windows
    }

    /*//////////////////////////////////////////////////////////////
                                SETTERS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the module state
     * @dev Only callable from the Module Manager
     */
    function setContractState(
        ModuleState newState
    ) external override onlyContract("MODULE_MANAGER", address(addressManager)) {
        moduleState = newState;
    }

    /**
     * @notice Set the date when revenues will be available to claim
     * @param timestamp The timestamp when revenues will be available to claim
     */
    function setAvailableDate(
        uint256 timestamp
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(timestamp > block.timestamp, RevShareModule__InvalidDate());
        revenuesAvailableDate = timestamp;

        emit OnAvailableDateSet(timestamp);
    }

    function setRewardsDuration(
        uint256 duration
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(duration > 0, RevShareModule__NotZeroValue());
        rewardsDuration = duration;
        emit OnRewardsDurationSet(duration);
    }

    /**
     * @notice Early release the revenues to be available to claim
     * @dev Only callable by an operator
     * @dev To be called in case the revenuesAvailableDate is set too far in the future
     */
    function releaseRevenues() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(block.timestamp < revenuesAvailableDate, RevShareModule__InvalidDate());
        revenuesAvailableDate = block.timestamp;
        emit OnAvailableDateSet(block.timestamp);
    }

    /*//////////////////////////////////////////////////////////////
                                DEPOSITS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Notify the contract about new revenue to be distributed
     * @param amount The amount of revenue to be distributed
     * @dev Only callable by specic contracts
     * @dev The contract must have enough allowance to transfer the tokens
     * @dev Splits deposits between Takadao (25%) and pioneers (75%)
     * @dev Sets new reward rates for both pools, with carry-over if the previous stream was not finished
     * @dev Increases the approved deposits for accounting purposes
     */
    function notifyNewRevenue(
        uint256 amount
    ) external onlyType(ProtocolAddressType.Module, address(addressManager)) nonReentrant {
        require(amount > 0, RevShareModule__NotZeroValue());

        // Update approved depoosits for accounting purposes
        approvedDeposits += amount;

        // Checkpoint (old rates are settled up to now)
        _updateGlobal();

        // Split betwen Takadao and pioneers
        uint256 pioneersShare = (amount * PIONEERS_SHARE) / 100;
        uint256 takadaoShare = (amount * TAKADAO_SHARE) / 100;

        // Recompute reward rates with carry-over
        uint256 currentTime = block.timestamp;
        if (currentTime >= block.timestamp) {
            rewardRatePioneers = pioneersShare / rewardsDuration;
            rewardRateTakadao = takadaoShare / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - currentTime;
            uint256 leftoverPioneers = remaining * rewardRatePioneers;
            uint256 leftoverTakadao = remaining * rewardRateTakadao;

            rewardRatePioneers = (pioneersShare + leftoverPioneers) / rewardsDuration;
            rewardRateTakadao = (takadaoShare + leftoverTakadao) / rewardsDuration;
        }

        lastUpdateTime = currentTime;
        periodFinish = currentTime + rewardsDuration;

        // Pull the tokens from the sender
        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );

        contributionToken.safeTransferFrom(msg.sender, address(this), amount);

        emit OnDeposit(amount);
    }

    /**
     * @notice Sweep the non approved deposits to avoid accounting issues
     * @dev Only callable by an operator
     */
    function sweepNonApprovedDeposits() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);

        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 balanceToSweep = contributionToken.balanceOf(address(this)) - approvedDeposits;

        if (balanceToSweep > 0) contributionToken.safeTransfer(msg.sender, balanceToSweep);
        else revert RevShareModule__NothingToSweep();

        emit OnBalanceSwept(balanceToSweep);
    }

    /*//////////////////////////////////////////////////////////////
                               EMERGENCY
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Emergency withdraw tokens from the contract
     * @dev Only callable by an operator
     * @dev Withdraws all the balance of the revenue token to the operator
     */
    function emergencyWithdraw() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 balance = contributionToken.balanceOf(address(this));
        contributionToken.safeTransfer(msg.sender, balance);
    }

    /*//////////////////////////////////////////////////////////////
                                 CLAIMS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Claim the revenue share earned by the pioneer
     * @return revenue The amount of revenue share claimed
     */
    function claimRevenueShare() external nonReentrant returns (uint256 revenue) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(
            block.timestamp >= revenuesAvailableDate,
            RevShareModule__RevenuesNotAvailableYet()
        );

        _updateRevenue(msg.sender);

        revenue = revenuePerPioneer[msg.sender];

        if (revenue > 0) {
            revenuePerPioneer[msg.sender] = 0;

            IERC20 contributionToken = IERC20(
                addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
            );
            contributionToken.safeTransfer(msg.sender, revenue);

            emit OnRevenueShareClaimed(msg.sender, revenue);
        }
    }

    /**
     * @notice Update the revenue share for a pioneer
     * @param pioneer The address of the pioneer
     */
    function updateRevenue(address pioneer) external {
        _updateRevenue(pioneer);
    }

    /*//////////////////////////////////////////////////////////////
                             VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function revenuePerNft() external view returns (uint256) {
        return _revenuePerNft();
    }

    /**
     * @notice View the revenue share earned by a pioneer so far
     * @param pioneer The address of the pioneer
     * @return The amount of revenue share earned
     */
    function earned(address pioneer) public view returns (uint256) {
        return _earned(pioneer);
    }

    function lastTimeApplicable() public view returns (uint256) {
        uint256 pf = periodFinish;

        if (pf == 0) return block.timestamp;
        return block.timestamp < pf ? block.timestamp : pf;
    }

    /**
     * @notice View the revenue to be distributed for a given duration
     * @param duration The duration in seconds
     * @return The amount of revenue to be distributed
     */
    function getRevenueForDuration(uint256 duration) external view returns (uint256) {
        return duration * rewardRate;
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @dev Updates the global revenue for both pools
    function _updateGlobal() internal {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );
        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply == 0) {
            lastUpdateTime = lastTimeApplicable();
            return; // Nothing to accumulate if there are no NFTs
        }

        revenuePerNftPioneers = _revenuePerNftPioneers();
        revenuePerNftTakadao = _revenuePerNftTakadao();
        lastUpdateTime = lastTimeApplicable();
    }

    function _updateRevenue(address _pioneer) internal {
        AddressAndStates._notZeroAddress(_pioneer);

        revenuePerNftOwned = _revenuePerNft();
        lastUpdateTime = lastTimeApplicable();

        revenuePerPioneer[_pioneer] = _earned(_pioneer);
        pioneerRevenuePerNftPaid[_pioneer] = revenuePerNftOwned;
    }

    function _revenuePerNft() internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        // TODO: Ask when finish the contract and tests
        // ? Question: Do we take into account the case where there are no NFTs minted from Takadao?
        uint256 totalSupply = revShareNFT.totalSupply();

        if (totalSupply == 0) return revenuePerNftOwned;

        // TODO: Check this decimals!!!!!
        // return
        //     revenuePerNftOwned +
        //     ((lastTimeApplicable() - lastUpdateTime) * rewardRate) /
        //     totalSupply;

        return
            revenuePerNftOwned +
            (((lastTimeApplicable() - lastUpdateTime) * rewardRate * PRECISION_FACTOR) /
                totalSupply);
    }

    function _revenuePerNftPioneers() internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply == 0) return revenuePerNftPioneers;

        uint256 elapsed = lastTimeApplicable() - lastUpdateTime;

        return
            revenuePerNftPioneers +
            ((elapsed * rewardRatePioneers * PRECISION_FACTOR) / currentSupply);
    }

    function _revenuePerNftTakadao() internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply == 0) return revenuePerNftTakadao;

        uint256 elapsed = lastTimeApplicable() - lastUpdateTime;

        return
            revenuePerNftTakadao +
            ((elapsed * rewardRateTakadao * PRECISION_FACTOR) / currentSupply);
    }

    function _earned(address _pioneer) internal view returns (uint256) {
        AddressAndStates._notZeroAddress(_pioneer);

        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        // TODO: Ask when finish the contract and tests
        // ? Question: Which balance do I take into account for Takadao? All none minted NFTs?
        return
            (revShareNFT.balanceOf(_pioneer) *
                (_revenuePerNft() - pioneerRevenuePerNftPaid[_pioneer])) /
            PRECISION_FACTOR +
            revenuePerPioneer[_pioneer];
    }

    ///@dev required by the OZ UUPS module
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(Roles.OPERATOR, address(addressManager)) {}
}

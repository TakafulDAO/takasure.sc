//SPDX-License-Identifier: GPL-3.0

/**
 * @title RevenueShareModule
 * @author Maikel Ordaz
 * @dev Allow NFT holders to receive a share of the revenue generated by the platform
 * @dev Upgradeable contract with UUPS pattern
 */
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IAddressManager} from "contracts/interfaces/IAddressManager.sol";
import {IRevShareNFT} from "contracts/interfaces/IRevShareNFT.sol";

import {UUPSUpgradeable, Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {ReentrancyGuardTransientUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol";
import {TLDModuleImplementation} from "contracts/modules/moduleUtils/TLDModuleImplementation.sol";

import {ModuleState, ProtocolAddressType} from "contracts/types/TakasureTypes.sol";
import {ModuleErrors} from "contracts/helpers/libraries/errors/ModuleErrors.sol";
import {Roles} from "contracts/helpers/libraries/constants/Roles.sol";
import {AddressAndStates} from "contracts/helpers/libraries/checks/AddressAndStates.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.28;

contract RevShareModule is
    TLDModuleImplementation,
    Initializable,
    UUPSUpgradeable,
    ReentrancyGuardTransientUpgradeable
{
    using SafeERC20 for IERC20;

    // New streaming state
    uint256 public rewardsDuration;
    uint256 public periodFinish; // Shared for both pools

    uint256 public approvedDeposits; // Total amount of approved deposits to be distributed as revenue
    uint256 public revenuesAvailableDate; // Timestamp to start the distribution. It does not mean the calculation starts at this date

    uint256 private constant PIONEERS_SHARE = 75; // In percentage (75%)
    uint256 private constant TAKADAO_SHARE = 25; // In percentage (25%)
    uint256 private constant PRECISION_FACTOR = 1e6;

    uint256 public rewardRateTakadao; // Reward rate per second to distribute among Takadao (25%)
    uint256 public rewardRatePioneers; // Reward rate per second to distribute among pioneers (75%)

    uint256 public lastUpdateTime;
    uint256 public revenuePerNftPioneers; // Cumulative revenue per NFT for pioneers pool
    uint256 public revenuePerNftTakadao; // Cumulative revenue per NFT for Takadao pool

    mapping(address pioneer => uint256 revenue) public revenuePerPioneer;
    mapping(address pioneer => uint256 revenue) public pioneerRevenuePerNftPaid;
    mapping(address => uint256) public takadaoRevenuePerNftPaid;

    /*//////////////////////////////////////////////////////////////
                           EVENTS AND ERRORS
    //////////////////////////////////////////////////////////////*/

    event OnAvailableDateSet(uint256 timestamp);
    event OnRewardsDurationSet(uint256 duration);
    event OnDeposit(uint256 amount);
    event OnBalanceSwept(uint256 amount);
    event OnRevenueShareClaimed(address indexed pioneer, uint256 amount);

    error RevShareModule__RevenuesNotAvailableYet();
    error RevShareModule__NotZeroValue();
    error RevShareModule__InvalidDate();
    error RevShareModule__NothingToSweep();

    /*//////////////////////////////////////////////////////////////
                             INITIALIZATION
    //////////////////////////////////////////////////////////////*/

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _addressManagerAddress) external initializer {
        AddressAndStates._notZeroAddress(_addressManagerAddress);
        __UUPSUpgradeable_init();
        __ReentrancyGuardTransient_init();

        addressManager = IAddressManager(_addressManagerAddress);

        revenuesAvailableDate = block.timestamp; // TODO: Change if needed

        rewardsDuration = 7 days; // default stream windows
    }

    /*//////////////////////////////////////////////////////////////
                                SETTERS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the module state
     * @dev Only callable from the Module Manager
     */
    function setContractState(
        ModuleState newState
    ) external override onlyContract("MODULE_MANAGER", address(addressManager)) {
        moduleState = newState;
    }

    /**
     * @notice Set the date when revenues will be available to claim
     * @param timestamp The timestamp when revenues will be available to claim
     */
    function setAvailableDate(
        uint256 timestamp
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(timestamp > block.timestamp, RevShareModule__InvalidDate());
        revenuesAvailableDate = timestamp;

        emit OnAvailableDateSet(timestamp);
    }

    function setRewardsDuration(
        uint256 duration
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(duration > 0, RevShareModule__NotZeroValue());
        rewardsDuration = duration;
        emit OnRewardsDurationSet(duration);
    }

    /**
     * @notice Early release the revenues to be available to claim
     * @dev Only callable by an operator
     * @dev To be called in case the revenuesAvailableDate is set too far in the future
     */
    function releaseRevenues() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(block.timestamp < revenuesAvailableDate, RevShareModule__InvalidDate());
        revenuesAvailableDate = block.timestamp;
        emit OnAvailableDateSet(block.timestamp);
    }

    /*//////////////////////////////////////////////////////////////
                                DEPOSITS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Notify the contract about new revenue to be distributed
     * @param amount The amount of revenue to be distributed
     * @dev Only callable by specic contracts
     * @dev The contract must have enough allowance to transfer the tokens
     * @dev Splits deposits between Takadao (25%) and pioneers (75%)
     * @dev Sets new reward rates for both pools, with carry-over if the previous stream was not finished
     * @dev Increases the approved deposits for accounting purposes
     */
    function notifyNewRevenue(
        uint256 amount
    ) external onlyType(ProtocolAddressType.Module, address(addressManager)) nonReentrant {
        require(amount > 0, RevShareModule__NotZeroValue());

        // Update approved depoosits for accounting purposes
        approvedDeposits += amount;

        // Checkpoint (old rates are settled up to now)
        _updateGlobal();

        // Split betwen Takadao and pioneers
        uint256 pioneersShare = (amount * PIONEERS_SHARE) / 100;
        uint256 takadaoShare = (amount * TAKADAO_SHARE) / 100;

        // Recompute reward rates with carry-over
        uint256 currentTime = block.timestamp;
        if (currentTime >= block.timestamp) {
            rewardRatePioneers = pioneersShare / rewardsDuration;
            rewardRateTakadao = takadaoShare / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - currentTime;
            uint256 leftoverPioneers = remaining * rewardRatePioneers;
            uint256 leftoverTakadao = remaining * rewardRateTakadao;

            rewardRatePioneers = (pioneersShare + leftoverPioneers) / rewardsDuration;
            rewardRateTakadao = (takadaoShare + leftoverTakadao) / rewardsDuration;
        }

        lastUpdateTime = currentTime;
        periodFinish = currentTime + rewardsDuration;

        // Pull the tokens from the sender
        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );

        contributionToken.safeTransferFrom(msg.sender, address(this), amount);

        emit OnDeposit(amount);
    }

    /**
     * @notice Sweep the non approved deposits to avoid accounting issues
     * @dev Only callable by an operator
     */
    function sweepNonApprovedDeposits() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);

        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 balanceToSweep = contributionToken.balanceOf(address(this)) - approvedDeposits;

        if (balanceToSweep > 0) contributionToken.safeTransfer(msg.sender, balanceToSweep);
        else revert RevShareModule__NothingToSweep();

        emit OnBalanceSwept(balanceToSweep);
    }

    /*//////////////////////////////////////////////////////////////
                               EMERGENCY
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Emergency withdraw tokens from the contract
     * @dev Only callable by an operator
     * @dev Withdraws all the balance of the revenue token to the operator
     */
    function emergencyWithdraw() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 balance = contributionToken.balanceOf(address(this));
        contributionToken.safeTransfer(msg.sender, balance);
    }

    /*//////////////////////////////////////////////////////////////
                                 CLAIMS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Claim the revenue share earned by the pioneer
     * @return revenue The amount of revenue share claimed
     */
    function claimRevenueShare() external nonReentrant returns (uint256 revenue) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(
            block.timestamp >= revenuesAvailableDate,
            RevShareModule__RevenuesNotAvailableYet()
        );

        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        address revenueReceiver = _getRevenueReceiver();
        bool isPioneer = revShareNFT.balanceOf(revenueReceiver) > 0;

        address beneficiary;

        if (isPioneer)
            beneficiary = msg.sender; // earns from pioneers stream
        else if (_callerIsClaimer())
            beneficiary = revenueReceiver; // earns from Takadao stream
        else revert ModuleErrors.Module__NotAuthorizedCaller(); // Only pioneers or the revenue claimer can call

        // Update global and user accruals
        _updateRevenue(beneficiary);

        revenue = revenuePerPioneer[beneficiary];

        if (revenue > 0) {
            revenuePerPioneer[beneficiary] = 0;

            IERC20 contributionToken = IERC20(
                addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
            );
            contributionToken.safeTransfer(beneficiary, revenue);

            // Sync approved deposits
            approvedDeposits -= revenue;

            emit OnRevenueShareClaimed(beneficiary, revenue);
        }
    }

    /**
     * @notice Update the revenue share for a pioneer
     * @param pioneer The address of the pioneer
     */
    function updateRevenue(address pioneer) external {
        _updateRevenue(pioneer);
    }

    /*//////////////////////////////////////////////////////////////
                             VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function lastTimeApplicable() public view returns (uint256) {
        return _lastTimeApplicable();
    }

    /**
     * @notice View the revenue to be distributed for a given duration
     * @param duration The duration in seconds
     * @return The amount of revenue to be distributed
     */
    function getRevenueForDuration(uint256 duration) external view returns (uint256, uint256) {
        return (duration * rewardRatePioneers, duration * rewardRateTakadao);
    }

    /// @notice View the revenue earned by a pioneer
    function earnedPioneers(address account) external view returns (uint256) {
        return _earnedPioneers(account);
    }

    /// @notice View the revenue earned by Takadao
    function earnedTakadao(address account) external view returns (uint256) {
        return _earnedTakadao(account);
    }

    /// @notice View the revenue per NFT for pioneers
    function getRevenuePerNftPioneers() external view returns (uint256) {
        return _revenuePerNftPioneers();
    }

    /// @notice View the revenue per NFT for Takadao
    function getRevenuePerNftTakadao() external view returns (uint256) {
        return _revenuePerNftTakadao();
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function _lastTimeApplicable() internal view returns (uint256) {
        uint256 _pf = periodFinish;

        if (_pf == 0) return block.timestamp;
        return block.timestamp < _pf ? block.timestamp : _pf;
    }

    function _getRevenueReceiver() internal view returns (address) {
        return addressManager.getProtocolAddressByName("REVENUE_RECEIVER").addr;
    }

    function _callerIsClaimer() internal view returns (bool) {
        return addressManager.hasRole(Roles.REVENUE_CLAIMER, msg.sender);
    }

    /// @dev Updates the global revenue for both pools
    function _updateGlobal() internal {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );
        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply == 0) {
            lastUpdateTime = _lastTimeApplicable();
            return; // Nothing to accumulate if there are no NFTs
        }

        revenuePerNftPioneers = _revenuePerNftPioneers();
        revenuePerNftTakadao = _revenuePerNftTakadao();
        lastUpdateTime = _lastTimeApplicable();
    }

    function _updateRevenue(address _account) internal {
        // Always update global state first
        _updateGlobal();

        // If account is address zero, we are done
        if (_account == address(0)) return;

        // Settle the account accruals on the corresponding stream
        // In pioneers stream everyone but the revenue receiver earns
        address revenueReceiver = _getRevenueReceiver();

        // Pioneers stream (75%)
        if (_account != revenueReceiver) {
            uint256 newEarnedPioneers = _earnedPioneers(_account);
            revenuePerPioneer[_account] = newEarnedPioneers;
            pioneerRevenuePerNftPaid[_account] = revenuePerNftPioneers;
        }

        // Takadao stream (25%)
        // Only the revenue receiver earns
        if (_account == revenueReceiver) {
            uint256 newEarnedTakadao = _earnedTakadao(_account);
            revenuePerPioneer[_account] = newEarnedTakadao; // Reuse the same revenue bucket
            takadaoRevenuePerNftPaid[_account] = revenuePerNftTakadao;
        }
    }

    function _revenuePerNftPioneers() internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply == 0) return revenuePerNftPioneers;

        uint256 elapsed = _lastTimeApplicable() - lastUpdateTime;

        return
            revenuePerNftPioneers +
            ((elapsed * rewardRatePioneers * PRECISION_FACTOR) / currentSupply);
    }

    function _revenuePerNftTakadao() internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        uint256 currentSupply = revShareNFT.totalSupply();

        if (currentSupply == 0) return revenuePerNftTakadao;

        uint256 elapsed = _lastTimeApplicable() - lastUpdateTime;

        return
            revenuePerNftTakadao +
            ((elapsed * rewardRateTakadao * PRECISION_FACTOR) / currentSupply);
    }

    function _earnedTakadao(address _account) internal view returns (uint256) {
        // Only the revenue receiver earns from this stream
        address revenueReceiver = _getRevenueReceiver();
        if (_account != revenueReceiver) return revenuePerPioneer[_account];

        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        uint256 balance = revShareNFT.balanceOf(_account);
        uint256 delta = _revenuePerNftTakadao() - takadaoRevenuePerNftPaid[_account];

        return (balance * delta) / PRECISION_FACTOR + revenuePerPioneer[_account];
    }

    function _earnedPioneers(address account) internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );
        address revenueReceiver = _getRevenueReceiver();

        if (account == revenueReceiver) {
            // Takadao does not participate in the 75% stream
            return revenuePerPioneer[account];
        }

        uint256 balance = revShareNFT.balanceOf(account);
        uint256 delta = _revenuePerNftPioneers() - pioneerRevenuePerNftPaid[account];

        return (balance * delta) / PRECISION_FACTOR + revenuePerPioneer[account];
    }

    ///@dev required by the OZ UUPS module
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(Roles.OPERATOR, address(addressManager)) {}
}

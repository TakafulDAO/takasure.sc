//SPDX-License-Identifier: GPL-3.0

/**
 * @title RevShareModule
 * @author Maikel Ordaz
 * @dev Allow NFT holders to receive a share of the revenue generated by the platform
 * @dev Important notes:
 *      1. It will mint a new NFT to all users that deposit maximum contribution
 *      2. It will mint a new NFT per each 250USDC expends by a coupon buyer
 * @dev Upgradeable contract with UUPS pattern
 */
import {IModuleManager} from "contracts/interfaces/IModuleManager.sol";
import {IPrejoinModule} from "contracts/interfaces/IPrejoinModule.sol";
import {ITakasureReserve} from "contracts/interfaces/ITakasureReserve.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {UUPSUpgradeable, Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {TLDModuleImplementation} from "contracts/modules/moduleUtils/TLDModuleImplementation.sol";

import {ModuleState} from "contracts/types/TakasureTypes.sol";
import {ModuleConstants} from "contracts/helpers/libraries/constants/ModuleConstants.sol";
import {AddressAndStates} from "contracts/helpers/libraries/checks/AddressAndStates.sol";
import {Member} from "contracts/types/TakasureTypes.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.28;

contract RevShareModule is
    Initializable,
    UUPSUpgradeable,
    AccessControlUpgradeable,
    TLDModuleImplementation,
    ERC721Upgradeable
{
    using SafeERC20 for IERC20;

    IModuleManager private moduleManager;
    IPrejoinModule private prejoinModule;
    ITakasureReserve private takasureReserve;
    IERC20 private usdc; // Revenue token

    address private takadaoOperator;

    ModuleState private moduleState;

    uint256 public constant MAX_CONTRIBUTION = 250e6; // 250 USDC
    uint256 public constant TOTAL_SUPPLY = 18_000;
    uint256 private constant DECIMAL_CORRECTION = 1e6;

    uint256 private revenueRate;
    uint256 private lastUpdatedTimestamp; // Last time the rewards were updated
    uint256 private revenuePerNFTOwned;

    bool private prejoinActive;

    uint256 public latestTokenId;

    mapping(address => uint256) public userRevenuePerNFTPaid;
    mapping(address => uint256) public revenues;

    mapping(address member => bool alreadyClaimed) public claimedNFTs;
    mapping(address couponBuyer => uint256 couponAmount) public couponAmountsByBuyer;

    /*//////////////////////////////////////////////////////////////
                            EVENTS & ERRORS
    //////////////////////////////////////////////////////////////*/

    event OnCouponBuyerAllowed(address indexed buyer, uint256 amount);
    event OnTakasureReserveSet(address indexed takasureReserve);
    event OnRevShareNFTMinted(address indexed member, uint256 tokenId);

    error RevShareModule__MaxSupplyReached();
    error RevShareModule__PrejoinStillActive();
    error RevShareModule__NotAllowedToMint();
    error RevShareModule__NoRevenueToClaim();

    /// @custom:oz-upgrades-unsafe-allow-constructor
    constructor() {
        _disableInitializers();
    }

    // TODO: Initialize the URI when set, skip for now just for easier testing
    function initialize(
        address _operator,
        address _moduleManager,
        address _prejoinModule,
        address _usdc
    ) external initializer {
        AddressAndStates._notZeroAddress(_operator);
        AddressAndStates._notZeroAddress(_moduleManager);

        __UUPSUpgradeable_init();
        __AccessControl_init();
        __ERC721_init("RevShareNFT", "RSNFT");

        _grantRole(ModuleConstants.TAKADAO_OPERATOR, _operator);
        _grantRole(ModuleConstants.MODULE_MANAGER, _moduleManager);

        moduleManager = IModuleManager(_moduleManager);
        prejoinModule = IPrejoinModule(_prejoinModule);
        usdc = IERC20(_usdc);
        takadaoOperator = _operator;

        prejoinActive = true;

        revenueRate = 1;
    }

    /*//////////////////////////////////////////////////////////////
                                SETTINGS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the module state
     *  @dev Only callble from the Module Manager
     */
    function setContractState(
        ModuleState newState
    ) external override onlyRole(ModuleConstants.MODULE_MANAGER) {
        moduleState = newState;
    }

    /**
     * @notice Set the Takasure Reserve contract when deployed
     */
    function setTakasureReserve(
        address _takasureReserve
    ) external onlyRole(ModuleConstants.TAKADAO_OPERATOR) {
        AddressAndStates._notZeroAddress(_takasureReserve);

        // To avoid unexpected behavior we need to ensure the prejoin is already disabled
        require(
            !moduleManager.isActiveModule(address(prejoinModule)),
            RevShareModule__PrejoinStillActive()
        );

        prejoinActive = false;
        takasureReserve = ITakasureReserve(_takasureReserve);

        emit OnTakasureReserveSet(_takasureReserve);
    }

    function allowCouponBuyer(
        address buyer,
        uint256 amount
    ) external onlyRole(ModuleConstants.TAKADAO_OPERATOR) {
        AddressAndStates._notZeroAddress(buyer);

        couponAmountsByBuyer[buyer] += amount;
        claimedNFTs[buyer] = false;

        emit OnCouponBuyerAllowed(buyer, amount);
    }

    /*//////////////////////////////////////////////////////////////
                                  MINT
    //////////////////////////////////////////////////////////////*/

    function mint() external {
        require(latestTokenId < TOTAL_SUPPLY, RevShareModule__MaxSupplyReached());

        // Check if the caller must be KYCed and paid the maximum contribution
        if (prejoinActive) {
            // If prejoin is active check in the Prejoin Module
            (uint256 contributionBeforeFee, , , ) = prejoinModule.getPrepaidMember(msg.sender);
            require(
                prejoinModule.isMemberKYCed(msg.sender) &&
                    contributionBeforeFee == MAX_CONTRIBUTION,
                RevShareModule__NotAllowedToMint()
            );
        } else {
            // Otherwise check in the Takasure Reserve
            Member memory member = takasureReserve.getMemberFromAddress(msg.sender);
            require(
                member.isKYCVerified && member.contribution == MAX_CONTRIBUTION,
                RevShareModule__NotAllowedToMint()
            );
        }

        // Update the revenues
        _updateRevenue(msg.sender);
        _updateRevenue(takadaoOperator);

        ++latestTokenId;
        claimedNFTs[msg.sender] = true;
        _safeMint(msg.sender, latestTokenId);

        emit OnRevShareNFTMinted(msg.sender, latestTokenId);
    }

    function batchMint() external {
        require(latestTokenId < TOTAL_SUPPLY, RevShareModule__MaxSupplyReached());
        require(
            couponAmountsByBuyer[msg.sender] >= MAX_CONTRIBUTION,
            RevShareModule__NotAllowedToMint()
        );

        // Update the revenues
        _updateRevenue(msg.sender);
        _updateRevenue(takadaoOperator);

        uint256 firstTokenId = latestTokenId + 1;
        uint256 lastTokenId = firstTokenId + (couponAmountsByBuyer[msg.sender] / MAX_CONTRIBUTION);

        latestTokenId = lastTokenId;

        for (uint256 i = firstTokenId; i <= lastTokenId; ++i) {
            claimedNFTs[msg.sender] = true;
            _safeMint(msg.sender, i);

            emit OnRevShareNFTMinted(msg.sender, i);
        }
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        _updateRevenue(from);
        _updateRevenue(to);

        super.transferFrom(from, to, tokenId);
    }

    /*//////////////////////////////////////////////////////////////
                             CLAIM REVENUE
    //////////////////////////////////////////////////////////////*/

    function claimRevenue() external {
        // Update the revenues
        _updateRevenue(msg.sender);

        uint256 revenue = revenues[msg.sender];

        require(revenue > 0, RevShareModule__NoRevenueToClaim());

        revenues[msg.sender] = 0;
        usdc.safeTransfer(msg.sender, revenue);
    }

    function getRevenuePerNFT() external view returns (uint256) {
        return _revenuePerNFT();
    }

    /**
     * @notice How much a user have earned in total
     */
    function getRevenueEarnedByUser(address user) external view returns (uint256) {
        return _revenueEarnedByUser(user);
    }

    /*//////////////////////////////////////////////////////////////
                           INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function _updateRevenue(address _user) internal {
        revenuePerNFTOwned = _revenuePerNFT();
        lastUpdatedTimestamp = block.timestamp;

        revenues[_user] = _revenueEarnedByUser(_user);
        userRevenuePerNFTPaid[_user] = revenuePerNFTOwned;
    }

    function _revenuePerNFT() internal view returns (uint256) {
        // TODO: Check the 1e6
        return (revenuePerNFTOwned +
            ((revenueRate * (block.timestamp - lastUpdatedTimestamp) * 1e6) / TOTAL_SUPPLY));
    }

    function _revenueEarnedByUser(address _user) internal view returns (uint256) {
        // TODO: Check the 1e6
        return (((balanceOf(_user) * (_revenuePerNFT() - userRevenuePerNFTPaid[_user])) / 1e6) +
            revenues[_user]);
    }

    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) internal override {
        _updateRevenue(from);
        _updateRevenue(to);

        super._safeTransfer(from, to, tokenId, data);
    }

    /**
     * @notice Needed override
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override(ERC721Upgradeable, AccessControlUpgradeable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(ModuleConstants.TAKADAO_OPERATOR) {}
}

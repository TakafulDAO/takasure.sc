//SPDX-License-Identifier: GPL-3.0

/**
 * @title RevenueShareModule
 * @author Maikel Ordaz
 * @dev Allow NFT holders to receive a share of the revenue generated by the platform
 * @dev Upgradeable contract with UUPS pattern
 */
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IAddressManager} from "contracts/interfaces/IAddressManager.sol";
import {IRevShareNFT} from "contracts/interfaces/IRevShareNFT.sol";

import {UUPSUpgradeable, Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {ReentrancyGuardTransientUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol";
import {TLDModuleImplementation} from "contracts/modules/moduleUtils/TLDModuleImplementation.sol";

import {ModuleState, ProtocolAddressType} from "contracts/types/TakasureTypes.sol";
import {ModuleErrors} from "contracts/helpers/libraries/errors/ModuleErrors.sol";
import {Roles} from "contracts/helpers/libraries/constants/Roles.sol";
import {AddressAndStates} from "contracts/helpers/libraries/checks/AddressAndStates.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.28;

contract RevShareModule is
    TLDModuleImplementation,
    Initializable,
    UUPSUpgradeable,
    ReentrancyGuardTransientUpgradeable
{
    using SafeERC20 for IERC20;

    uint256 public approvedDeposits; // Total amount of approved deposits to be distributed as revenue
    uint256 public revenuesAvailableDate; // Timestamp to start the distribution. It does not mean the calculation starts at this date
    uint256 public lastTimestampToDistributeRevenues; // Last timestamp to distribute revenues when distributions are turned off. 0 if distributions are active
    bool public distributionsActive;

    // TODO: Ask at the end, deliver the math first. For now will be 0
    // ? Question: Still not clear if this is 75% and 25% and we differentiate different reward rate according the caller
    // ? Or if it is the same reward rate for all th callers but we apply the formula just for the 75% or 25% of the balance depending on the caller
    uint256 public rewardRate; // Reward rate per second to distribute among NFT holders
    uint256 public lastUpdateTime;
    uint256 public revenuePerNftOwned; // Accumulates the total revenue a single NFT has earned if it was owned since the beginning

    uint256 private constant PRECISION_FACTOR = 1e6;
    uint256 private constant TAKADAO_SHARE = 25; // In percentage (25%)
    uint256 private constant PIONEERS_SHARE = 75; // In percentage (75%)

    mapping(address pioneer => uint256 revenue) public revenuePerPioneer;
    mapping(address pioneer => uint256 revenue) public pioneerRevenuePerNftPaid;

    /*//////////////////////////////////////////////////////////////
                           EVENTS AND ERRORS
    //////////////////////////////////////////////////////////////*/

    event OnAvailableDateSet(uint256 timestamp);
    event OnDistributionsActiveSet(bool active, uint256 periodFinish);
    event OnTakadaoAddressAdded(address indexed addr);
    event OnTakadaoAddressRemoved(address indexed addr);
    event OnDeposit(uint256 amount);
    event OnBalanceSwept(uint256 amount);
    event OnRevenueShareClaimed(address indexed pioneer, uint256 amount);

    error RevShareModule__RevenuesNotAvailableYet();
    error RevShareModule__NotZeroAmount();
    error RevShareModule__InvalidDate();
    error RevShareModule__NotTakadaoAddress();
    error RevShareModule__NothingToSweep();

    /*//////////////////////////////////////////////////////////////
                             INITIALIZATION
    //////////////////////////////////////////////////////////////*/

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _addressManagerAddress) external initializer {
        AddressAndStates._notZeroAddress(_addressManagerAddress);
        __UUPSUpgradeable_init();
        __ReentrancyGuardTransient_init();

        addressManager = IAddressManager(_addressManagerAddress);

        distributionsActive = true;
        revenuesAvailableDate = block.timestamp; // TODO: Change if needed
    }

    /*//////////////////////////////////////////////////////////////
                                SETTERS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the module state
     * @dev Only callable from the Module Manager
     */
    function setContractState(
        ModuleState newState
    ) external override onlyContract("MODULE_MANAGER", address(addressManager)) {
        moduleState = newState;
    }

    /**
     * @notice Set the date when revenues will be available to claim
     * @param timestamp The timestamp when revenues will be available to claim
     */
    function setAvailableDate(
        uint256 timestamp
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(timestamp > block.timestamp, RevShareModule__InvalidDate());
        revenuesAvailableDate = timestamp;

        emit OnAvailableDateSet(timestamp);
    }

    /**
     * @notice Early release the revenues to be available to claim
     * @dev Only callable by an operator
     * @dev To be called in case the revenuesAvailableDate is set too far in the future
     */
    function releaseRevenues() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(block.timestamp < revenuesAvailableDate, RevShareModule__InvalidDate());
        revenuesAvailableDate = block.timestamp;
        emit OnAvailableDateSet(block.timestamp);
    }

    /**
     * @notice Set if distributions are active or not
     * @param active True if distributions are active, false otherwise
     * @param periodFinish Timestamp to stop the distributions if active is false
     * @dev Only callable by an operator
     */
    function setDistributionsActive(
        bool active,
        uint256 periodFinish
    ) external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        distributionsActive = active;

        // If active is true, reset the timestamp, but if false, set the timestamp when distributions will stop
        if (active) {
            lastTimestampToDistributeRevenues = 0;
        } else {
            require(periodFinish > block.timestamp, RevShareModule__InvalidDate());
            lastTimestampToDistributeRevenues = periodFinish;
        }

        emit OnDistributionsActiveSet(distributionsActive, lastTimestampToDistributeRevenues);
    }

    /*//////////////////////////////////////////////////////////////
                                DEPOSITS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Notify the contract about new revenue to be distributed
     * @param amount The amount of revenue to be distributed
     * @dev Only callable by specic contracts
     * @dev The contract must have enough allowance to transfer the tokens
     */
    function notifyNewRevenue(
        uint256 amount
    ) external onlyType(ProtocolAddressType.Module, address(addressManager)) nonReentrant {
        require(amount > 0, RevShareModule__NotZeroAmount());

        approvedDeposits += amount;

        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );

        contributionToken.safeTransferFrom(msg.sender, address(this), amount);

        emit OnDeposit(amount);
    }

    /**
     * @notice Sweep the non approved deposits to avoid accounting issues
     * @dev Only callable by an operator
     */
    function sweepNonApprovedDeposits() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);

        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 balanceToSweep = contributionToken.balanceOf(address(this)) - approvedDeposits;

        if (balanceToSweep > 0) contributionToken.safeTransfer(msg.sender, balanceToSweep);
        else revert RevShareModule__NothingToSweep();

        emit OnBalanceSwept(balanceToSweep);
    }

    /*//////////////////////////////////////////////////////////////
                               EMERGENCY
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Emergency withdraw tokens from the contract
     * @dev Only callable by an operator
     * @dev Withdraws all the balance of the revenue token to the operator
     */
    function emergencyWithdraw() external onlyRole(Roles.OPERATOR, address(addressManager)) {
        IERC20 contributionToken = IERC20(
            addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
        );
        uint256 balance = contributionToken.balanceOf(address(this));
        contributionToken.safeTransfer(msg.sender, balance);
    }

    /*//////////////////////////////////////////////////////////////
                                 CLAIMS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Claim the revenue share earned by the pioneer
     * @return revenue The amount of revenue share claimed
     */
    function claimRevenueShare() external nonReentrant returns (uint256 revenue) {
        AddressAndStates._onlyModuleState(moduleState, ModuleState.Enabled);
        require(
            block.timestamp >= revenuesAvailableDate,
            RevShareModule__RevenuesNotAvailableYet()
        );

        _updateRevenue(msg.sender);

        revenue = revenuePerPioneer[msg.sender];

        if (revenue > 0) {
            revenuePerPioneer[msg.sender] = 0;

            IERC20 contributionToken = IERC20(
                addressManager.getProtocolAddressByName("CONTRIBUTION_TOKEN").addr
            );
            contributionToken.safeTransfer(msg.sender, revenue);

            emit OnRevenueShareClaimed(msg.sender, revenue);
        }
    }

    /**
     * @notice Update the revenue share for a pioneer
     * @param pioneer The address of the pioneer
     */
    function updateRevenue(address pioneer) external {
        _updateRevenue(pioneer);
    }

    /*//////////////////////////////////////////////////////////////
                             VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function revenuePerNft() external view returns (uint256) {
        return _revenuePerNft();
    }

    /**
     * @notice View the revenue share earned by a pioneer so far
     * @param pioneer The address of the pioneer
     * @return The amount of revenue share earned
     */
    function earned(address pioneer) public view returns (uint256) {
        return _earned(pioneer);
    }

    function lastTimeApplicable() public view returns (uint256) {
        if (distributionsActive) return block.timestamp;
        else
            return
                block.timestamp < lastTimestampToDistributeRevenues
                    ? block.timestamp
                    : lastTimestampToDistributeRevenues;
    }

    /**
     * @notice View the revenue to be distributed for a given duration
     * @param duration The duration in seconds
     * @return The amount of revenue to be distributed
     */
    function getRevenueForDuration(uint256 duration) external view returns (uint256) {
        return duration * rewardRate;
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function _updateRevenue(address _pioneer) internal {
        AddressAndStates._notZeroAddress(_pioneer);

        revenuePerNftOwned = _revenuePerNft();
        lastUpdateTime = lastTimeApplicable();

        revenuePerPioneer[_pioneer] = _earned(_pioneer);
        pioneerRevenuePerNftPaid[_pioneer] = revenuePerNftOwned;
    }

    function _revenuePerNft() internal view returns (uint256) {
        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        // TODO: Ask when finish the contract and tests
        // ? Question: Do we take into account the case where there are no NFTs minted from Takadao?
        uint256 totalSupply = revShareNFT.totalSupply();

        if (totalSupply == 0) return revenuePerNftOwned;

        // TODO: Check this decimals!!!!!
        // return
        //     revenuePerNftOwned +
        //     ((lastTimeApplicable() - lastUpdateTime) * rewardRate) /
        //     totalSupply;

        return
            revenuePerNftOwned +
            (((lastTimeApplicable() - lastUpdateTime) * rewardRate * PRECISION_FACTOR) /
                totalSupply);
    }

    function _earned(address _pioneer) internal view returns (uint256) {
        AddressAndStates._notZeroAddress(_pioneer);

        IRevShareNFT revShareNFT = IRevShareNFT(
            addressManager.getProtocolAddressByName("REVSHARE_NFT").addr
        );

        // TODO: Ask when finish the contract and tests
        // ? Question: Which balance do I take into account for Takadao? All none minted NFTs?
        return
            (revShareNFT.balanceOf(_pioneer) *
                (_revenuePerNft() - pioneerRevenuePerNftPaid[_pioneer])) /
            PRECISION_FACTOR +
            revenuePerPioneer[_pioneer];
    }

    ///@dev required by the OZ UUPS module
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(Roles.OPERATOR, address(addressManager)) {}
}
